//冒泡算法

int[] array={ 3, 1, 6, 2, 9, 0, 7, 4, 5, 8 ,10,23,12,23,45,16,18,19,188};
      int temp;
     for(int i=0;i<array.length;i++){
    	 boolean flag = true;
    	for(int j=0;j<array.length-1-i;j++){
    		if(array[j]>array[j+1]){
    			temp=array[j];
    			array[j]=array[j+1];
    			array[j+1]=temp;
    			flag=false;
    		}
    		//if(flag){
    			//break;
    		//}
    	}    	
     for (int t: array){
    	 System.out.print(Arrays.toString(array);
     }
//二分法检索数据
     int[] arr = { 30,20,50,10,80,9,7,12,100,40,8};
     int searchWord = 20; // 所要查找的数
     Arrays.sort(arr); //数组元素排序
     System.out.println(Arrays.toString(arr));
     int low = 0;
     int high = arr.length - 1;
     while(low<=high){
    	 int middle=(low+high)/2;
    	 if(searchWord==arr[middle]){
    		System.out.println(middle);
		break;
    	 }
    	 if(searchWord > array[middle]){
             low = middle + 1;
         }
         if(searchWord < array[middle]){
             high = middle - 1;
         }
     }
     
     
     
     //以上二分法查找数据的时候发现会陷入死循环，原因是找到数据的时候 最大值和最小值是相等的导致while循环恒成立 所以出现反复打印输出值
     
    //可以通过加break 或者返回该数据解决
    
  //直接选择排序从小到大
  import java.util.Arrays;

public class SelectSort {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//使用直接选择排序算法，比冒泡算法快一点
       int[] arr={3, 1, 6, 2, 9, 0, 7, 4,5,8};
       for(int i=0;i<arr.length-1;i++){
    	   //保存最大的值
    	   int index=0;
    	  for(int j=0;j<arr.length-i-1;j++){
    		  if(arr[j+1]>arr[index]){
    			  index=j+1;
    		  }
    	  }
          swap(arr,index,arr.length-i-1);
       }
      System.out.println(Arrays.toString(arr));
    		   
	}
	public static void swap(int[] array,int i,int j){
		int temp=array[i];
		array[i]=array[j];
		array[j]=temp;
	}

}



